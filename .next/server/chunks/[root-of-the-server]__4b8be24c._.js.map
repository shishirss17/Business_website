{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/shish/Downloads/studio/src/auth.config.ts"],"sourcesContent":["import type { NextAuthConfig } from \"next-auth\"\r\n\r\nexport const authConfig = {\r\n    pages: {\r\n        signIn: '/login',\r\n    },\r\n    callbacks: {\r\n        /*authorized({ auth, request: { nextUrl } }) {\r\n          const isLoggedIn = !!auth?.user;\r\n          const isOnDashboard = nextUrl.pathname.startsWith('/dashboard');\r\n          if (isOnDashboard) {\r\n            if (isLoggedIn) return true;\r\n            return false; // Redirect unauthenticated users to login page\r\n          }\r\n          return true;\r\n        },*/\r\n        async jwt({ token, user }) {\r\n            if (user) {\r\n                token.phoneNumber = (user as any).phoneNumber;\r\n                token.role = (user as any).role;\r\n                token.id = user.id;\r\n            }\r\n            return token;\r\n        },\r\n        async session({ session, token }) {\r\n            if (session.user) {\r\n                (session.user as any).phoneNumber = token.phoneNumber;\r\n                (session.user as any).role = token.role;\r\n                (session.user as any).id = token.id;\r\n            }\r\n            return session;\r\n        },\r\n    },\r\n    providers: [],\r\n    session: {\r\n        strategy: \"jwt\",\r\n    },\r\n} satisfies NextAuthConfig\r\n"],"names":[],"mappings":";;;AAEO,MAAM,aAAa;IACtB,OAAO;QACH,QAAQ;IACZ;IACA,WAAW;QACP;;;;;;;;UAQE,GACF,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACrB,IAAI,MAAM;gBACN,MAAM,WAAW,GAAG,AAAC,KAAa,WAAW;gBAC7C,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI;gBAC/B,MAAM,EAAE,GAAG,KAAK,EAAE;YACtB;YACA,OAAO;QACX;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC5B,IAAI,QAAQ,IAAI,EAAE;gBACb,QAAQ,IAAI,CAAS,WAAW,GAAG,MAAM,WAAW;gBACpD,QAAQ,IAAI,CAAS,IAAI,GAAG,MAAM,IAAI;gBACtC,QAAQ,IAAI,CAAS,EAAE,GAAG,MAAM,EAAE;YACvC;YACA,OAAO;QACX;IACJ;IACA,WAAW,EAAE;IACb,SAAS;QACL,UAAU;IACd;AACJ","debugId":null}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/shish/Downloads/studio/src/lib/db.ts"],"sourcesContent":["import mongoose from 'mongoose';\r\n\r\nconst MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/cuddlecart';\r\n\r\nif (!MONGODB_URI) {\r\n  throw new Error(\r\n    'Please define the MONGODB_URI environment variable inside .env.local'\r\n  );\r\n}\r\n\r\n/**\r\n * Global is used here to maintain a cached connection across hot reloads\r\n * in development. This prevents connections growing exponentially\r\n * during API Route usage.\r\n */\r\nlet cached = (global as any).mongoose;\r\n\r\nif (!cached) {\r\n  cached = (global as any).mongoose = { conn: null, promise: null };\r\n}\r\n\r\nasync function dbConnect() {\r\n  if (cached.conn) {\r\n    return cached.conn;\r\n  }\r\n\r\n  if (!cached.promise) {\r\n    const opts = {\r\n      bufferCommands: false,\r\n    };\r\n\r\n    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {\r\n      return mongoose;\r\n    });\r\n  }\r\n  try {\r\n    cached.conn = await cached.promise;\r\n  } catch (e) {\r\n    cached.promise = null;\r\n    throw e;\r\n  }\r\n\r\n  return cached.conn;\r\n}\r\n\r\nexport default dbConnect;\r\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW,IAAI;AAE/C,uCAAkB;;AAIlB;AAEA;;;;CAIC,GACD,IAAI,SAAS,AAAC,OAAe,QAAQ;AAErC,IAAI,CAAC,QAAQ;IACX,SAAS,AAAC,OAAe,QAAQ,GAAG;QAAE,MAAM;QAAM,SAAS;IAAK;AAClE;AAEA,eAAe;IACb,IAAI,OAAO,IAAI,EAAE;QACf,OAAO,OAAO,IAAI;IACpB;IAEA,IAAI,CAAC,OAAO,OAAO,EAAE;QACnB,MAAM,OAAO;YACX,gBAAgB;QAClB;QAEA,OAAO,OAAO,GAAG,yGAAA,CAAA,UAAQ,CAAC,OAAO,CAAC,aAAa,MAAM,IAAI,CAAC,CAAC;YACzD,OAAO;QACT;IACF;IACA,IAAI;QACF,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;IACpC,EAAE,OAAO,GAAG;QACV,OAAO,OAAO,GAAG;QACjB,MAAM;IACR;IAEA,OAAO,OAAO,IAAI;AACpB;uCAEe","debugId":null}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/shish/Downloads/studio/src/models/User.ts"],"sourcesContent":["import mongoose, { Schema, Document } from 'mongoose';\r\n\r\nexport interface IUser extends Document {\r\n    email: string;\r\n    password?: string;\r\n    name?: string;\r\n    phoneNumber?: string;\r\n    addresses?: Array<{\r\n        id: string;\r\n        type: string;\r\n        address: string;\r\n        isDefault: boolean;\r\n    }>;\r\n    role: 'user' | 'admin';\r\n    createdAt: Date;\r\n    updatedAt: Date;\r\n}\r\n\r\nconst UserSchema: Schema = new Schema({\r\n    email: { type: String, required: true, unique: true },\r\n    password: { type: String, required: false }, // Optional for OAuth users in future\r\n    name: { type: String },\r\n    phoneNumber: { type: String },\r\n    addresses: [{\r\n        id: { type: String },\r\n        type: { type: String },\r\n        address: { type: String },\r\n        isDefault: { type: Boolean, default: false }\r\n    }],\r\n    role: { type: String, enum: ['user', 'admin'], default: 'user' },\r\n}, {\r\n    timestamps: true,\r\n});\r\n\r\nexport default mongoose.models.User || mongoose.model<IUser>('User', UserSchema);\r\n"],"names":[],"mappings":";;;AAAA;;AAkBA,MAAM,aAAqB,IAAI,yGAAA,CAAA,SAAM,CAAC;IAClC,OAAO;QAAE,MAAM;QAAQ,UAAU;QAAM,QAAQ;IAAK;IACpD,UAAU;QAAE,MAAM;QAAQ,UAAU;IAAM;IAC1C,MAAM;QAAE,MAAM;IAAO;IACrB,aAAa;QAAE,MAAM;IAAO;IAC5B,WAAW;QAAC;YACR,IAAI;gBAAE,MAAM;YAAO;YACnB,MAAM;gBAAE,MAAM;YAAO;YACrB,SAAS;gBAAE,MAAM;YAAO;YACxB,WAAW;gBAAE,MAAM;gBAAS,SAAS;YAAM;QAC/C;KAAE;IACF,MAAM;QAAE,MAAM;QAAQ,MAAM;YAAC;YAAQ;SAAQ;QAAE,SAAS;IAAO;AACnE,GAAG;IACC,YAAY;AAChB;uCAEe,yGAAA,CAAA,UAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,yGAAA,CAAA,UAAQ,CAAC,KAAK,CAAQ,QAAQ","debugId":null}},
    {"offset": {"line": 231, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/shish/Downloads/studio/src/models/Otp.ts"],"sourcesContent":["import mongoose, { Schema, Document } from 'mongoose';\r\n\r\nexport interface IOtp extends Document {\r\n    phoneNumber: string;\r\n    code: string;\r\n    expiresAt: Date;\r\n}\r\n\r\nconst OtpSchema: Schema = new Schema({\r\n    phoneNumber: { type: String, required: true },\r\n    code: { type: String, required: true },\r\n    expiresAt: { type: Date, required: true, index: { expires: '0s' } }, // Auto-delete on expiration\r\n}, {\r\n    timestamps: true,\r\n});\r\n\r\nexport default mongoose.models.Otp || mongoose.model<IOtp>('Otp', OtpSchema);\r\n"],"names":[],"mappings":";;;AAAA;;AAQA,MAAM,YAAoB,IAAI,yGAAA,CAAA,SAAM,CAAC;IACjC,aAAa;QAAE,MAAM;QAAQ,UAAU;IAAK;IAC5C,MAAM;QAAE,MAAM;QAAQ,UAAU;IAAK;IACrC,WAAW;QAAE,MAAM;QAAM,UAAU;QAAM,OAAO;YAAE,SAAS;QAAK;IAAE;AACtE,GAAG;IACC,YAAY;AAChB;uCAEe,yGAAA,CAAA,UAAQ,CAAC,MAAM,CAAC,GAAG,IAAI,yGAAA,CAAA,UAAQ,CAAC,KAAK,CAAO,OAAO","debugId":null}},
    {"offset": {"line": 262, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/shish/Downloads/studio/src/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\"\r\nimport Credentials from \"next-auth/providers/credentials\"\r\nimport { authConfig } from \"./auth.config\"\r\nimport dbConnect from \"@/lib/db\"\r\nimport User from \"@/models/User\"\r\nimport Otp from \"@/models/Otp\"\r\n\r\nexport const { handlers, signIn, signOut, auth } = NextAuth({\r\n    ...authConfig,\r\n    providers: [\r\n        // --- Provider 1: Email + Password ---\r\n        Credentials({\r\n            id: \"email-password\",\r\n            name: \"Email and Password\",\r\n            credentials: {\r\n                email: { label: \"Email\", type: \"email\" },\r\n                password: { label: \"Password\", type: \"password\" },\r\n            },\r\n            authorize: async (credentials) => {\r\n                await dbConnect();\r\n                const email = credentials.email as string;\r\n                const password = credentials.password as string;\r\n\r\n                if (!email || !password) {\r\n                    throw new Error(\"Missing email or password\");\r\n                }\r\n\r\n                const user = await User.findOne({ email });\r\n                if (!user) {\r\n                    throw new Error(\"User not found\");\r\n                }\r\n\r\n                if (!user.password) {\r\n                    throw new Error(\"Invalid credentials\");\r\n                }\r\n\r\n                const bcrypt = require('bcryptjs');\r\n                const isValid = await bcrypt.compare(password, user.password);\r\n\r\n                if (!isValid) {\r\n                    throw new Error(\"Invalid password\");\r\n                }\r\n\r\n                return {\r\n                    id: user._id.toString(),\r\n                    email: user.email,\r\n                    name: user.name,\r\n                    role: user.role,\r\n                    phoneNumber: user.phoneNumber,\r\n                };\r\n            },\r\n        }),\r\n\r\n        // --- Provider 2: Mobile OTP ---\r\n        Credentials({\r\n            id: \"mobile-otp\",\r\n            name: \"Mobile OTP\",\r\n            credentials: {\r\n                phoneNumber: { label: \"Phone Number\", type: \"tel\" },\r\n                otp: { label: \"OTP\", type: \"text\" },\r\n            },\r\n            authorize: async (credentials) => {\r\n                await dbConnect();\r\n                const phoneNumber = credentials.phoneNumber as string;\r\n                const otp = credentials.otp as string;\r\n\r\n                if (!phoneNumber || !otp) {\r\n                    throw new Error(\"Phone number and OTP are required\");\r\n                }\r\n\r\n                // Find the stored OTP record\r\n                const otpRecord = await Otp.findOne({ phoneNumber });\r\n\r\n                if (!otpRecord) {\r\n                    throw new Error(\"OTP not found or already used. Please request a new one.\");\r\n                }\r\n\r\n                // Check expiry\r\n                if (new Date() > otpRecord.expiresAt) {\r\n                    await Otp.deleteOne({ _id: otpRecord._id });\r\n                    throw new Error(\"OTP has expired. Please request a new one.\");\r\n                }\r\n\r\n                // Compare OTP using timing-safe comparison\r\n                const crypto = require('crypto');\r\n                const isMatch = crypto.timingSafeEqual(\r\n                    Buffer.from(otpRecord.code),\r\n                    Buffer.from(otp)\r\n                );\r\n\r\n                if (!isMatch) {\r\n                    throw new Error(\"Invalid OTP\");\r\n                }\r\n\r\n                // Delete the used OTP immediately (one-time use)\r\n                await Otp.deleteOne({ _id: otpRecord._id });\r\n\r\n                // Find the user linked to this phone number\r\n                const user = await User.findOne({ phoneNumber });\r\n                if (!user) {\r\n                    throw new Error(\"No account found for this phone number\");\r\n                }\r\n\r\n                return {\r\n                    id: user._id.toString(),\r\n                    email: user.email,\r\n                    name: user.name,\r\n                    role: user.role,\r\n                    phoneNumber: user.phoneNumber,\r\n                };\r\n            },\r\n        }),\r\n    ],\r\n})\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 398, "column": 0}, "map": {"version":3,"sources":["file://C%3A/Users/shish/Downloads/studio/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import { handlers } from \"@/auth\"\r\n\r\nexport const { GET, POST } = handlers\r\n"],"names":[],"mappings":";;;;AAAA;;AAEO,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,6GAAA,CAAA,WAAQ","debugId":null}}]
}